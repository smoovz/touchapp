<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-chart-interactions-Crosshair'>/**
</span> * The Crosshair interaction allows the user to get precise values for a specific point on the chart.
 * The values are obtained by single-touch dragging on the chart.
 *
 *     @example preview
 *     var lineChart = Ext.create(&#39;Ext.chart.CartesianChart&#39;, {
 *         innerPadding: 20,
 *         interactions: [{
 *             type: &#39;crosshair&#39;,
 *             axes: {
 *                 left: {
 *                     label: {
 *                         fillStyle: &#39;white&#39;
 *                     },
 *                     rect: {
 *                         fillStyle: &#39;brown&#39;,
 *                         radius: 6
 *                     }
 *                 },
 *                 bottom: {
 *                     label: {
 *                         fontSize: &#39;14px&#39;,
 *                         fontWeight: &#39;bold&#39;
 *                     }
 *                 }
 *             },
 *             lines: {
 *                 horizontal: {
 *                     strokeStyle: &#39;brown&#39;,
 *                     lineWidth: 2,
 *                     lineDash: [20, 2, 2, 2, 2, 2, 2, 2]
 *                 }
 *             }
 *         }],
 *         store: {
 *             fields: [&#39;name&#39;, &#39;data&#39;],
 *             data: [
 *                 {name: &#39;apple&#39;, data: 300},
 *                 {name: &#39;orange&#39;, data: 900},
 *                 {name: &#39;banana&#39;, data: 800},
 *                 {name: &#39;pear&#39;, data: 400},
 *                 {name: &#39;grape&#39;, data: 500}
 *             ]
 *         },
 *         axes: [{
 *             type: &#39;numeric&#39;,
 *             position: &#39;left&#39;,
 *             fields: [&#39;data&#39;],
 *             title: {
 *                 text: &#39;Value&#39;,
 *                 fontSize: 15
 *             },
 *             grid: true,
 *             label: {
 *                 rotationRads: -Math.PI / 4
 *             }
 *         }, {
 *             type: &#39;category&#39;,
 *             position: &#39;bottom&#39;,
 *             fields: [&#39;name&#39;],
 *             title: {
 *                 text: &#39;Category&#39;,
 *                 fontSize: 15
 *             }
 *         }],
 *         series: [{
 *             type: &#39;line&#39;,
 *             style: {
 *                 strokeStyle: &#39;black&#39;
 *             },
 *             xField: &#39;name&#39;,
 *             yField: &#39;data&#39;,
 *             marker: {
 *                 type: &#39;circle&#39;,
 *                 radius: 5,
 *                 fillStyle: &#39;lightblue&#39;
 *             }
 *         }]
 *     });
 *     Ext.Viewport.setLayout(&#39;fit&#39;);
 *     Ext.Viewport.add(lineChart);
 */

Ext.define(&#39;Ext.chart.interactions.Crosshair&#39;, {

    extend: &#39;Ext.chart.interactions.Abstract&#39;,
    requires: [
        &#39;Ext.chart.grid.HorizontalGrid&#39;,
        &#39;Ext.chart.grid.VerticalGrid&#39;,
        &#39;Ext.chart.CartesianChart&#39;,
        &#39;Ext.chart.axis.layout.Discrete&#39;
    ],

<span id='Ext-chart-interactions-Crosshair-property-type'>    type: &#39;crosshair&#39;,
</span>    alias: &#39;interaction.crosshair&#39;,

    config: {
<span id='Ext-chart-interactions-Crosshair-cfg-axes'>        /**
</span>         * @cfg {Object} axes
         * Specifies label text and label rect configs on per axis basis or as a single config for all axes.
         *
         *     {
         *         type: &#39;crosshair&#39;,
         *         axes: {
         *             label: { fillStyle: &#39;white&#39; },
         *             rect: { fillStyle: &#39;maroon&#39;}
         *         }
         *     }
         *
         * In case per axis configuration is used, an object with keys corresponding
         * to the {@link Ext.chart.axis.Axis#position position} must be provided.
         *
         *     {
         *         type: &#39;crosshair&#39;,
         *         axes: {
         *             left: {
         *                 label: { fillStyle: &#39;white&#39; },
         *                 rect: {
         *                     fillStyle: &#39;maroon&#39;,
         *                     radius: 4
         *                 }
         *             },
         *             bottom: {
         *                 label: {
         *                     fontSize: &#39;14px&#39;,
         *                     fontWeight: &#39;bold&#39;
         *                 },
         *                 rect: { fillStyle: &#39;white&#39; }
         *             }
         *         }
         *
         * If the `axes` config is not specified, the following defaults will be used:
         * - `label` will use values from the {@link Ext.chart.axis.Axis#label label} config.
         * - `rect` will use the &#39;white&#39; fillStyle.
         */
        axes: {
            top: {label: {}, rect: {}},
            right: {label: {}, rect: {}},
            bottom: {label: {}, rect: {}},
            left: {label: {}, rect: {}}
        },

<span id='Ext-chart-interactions-Crosshair-cfg-lines'>        /**
</span>         * @cfg {Object} lines
         * Specifies attributes of horizontal and vertical lines that make up the crosshair.
         * If this config is missing, black dashed lines will be used.
         *
         *     {
         *         horizontal: {
         *             strokeStyle: &#39;red&#39;,
         *             lineDash: [] // solid line
         *         },
         *         vertical: {
         *             lineWidth: 2,
         *             lineDash: [15, 5, 5, 5]
         *         }
         *     }
         */
        lines: {
            horizontal: {
                strokeStyle: &#39;black&#39;,
                lineDash: [5, 5]
            },
            vertical: {
                strokeStyle: &#39;black&#39;,
                lineDash: [5, 5]
            }
        },
<span id='Ext-chart-interactions-Crosshair-cfg-gesture'>        gesture: &#39;drag&#39;
</span>    },

<span id='Ext-chart-interactions-Crosshair-method-applyAxes'>    applyAxes: function (axesConfig, oldAxesConfig) {
</span>        return Ext.merge(oldAxesConfig || {}, axesConfig);
    },

<span id='Ext-chart-interactions-Crosshair-method-applyLines'>    applyLines: function (linesConfig, oldLinesConfig) {
</span>        return Ext.merge(oldLinesConfig || {}, linesConfig);
    },

<span id='Ext-chart-interactions-Crosshair-method-updateChart'>    updateChart: function (chart) {
</span>        if (!(chart instanceof Ext.chart.CartesianChart)) {
            throw &#39;Crosshair interaction can only be used on cartesian charts.&#39;;
        }
        this.callParent(arguments);
    },

<span id='Ext-chart-interactions-Crosshair-method-getGestures'>    getGestures: function () {
</span>        var me = this,
            gestures = {};
        gestures[me.getGesture()] = &#39;onGesture&#39;;
        gestures[me.getGesture() + &#39;start&#39;] = &#39;onGestureStart&#39;;
        gestures[me.getGesture() + &#39;end&#39;] = &#39;onGestureEnd&#39;;
        return gestures;
    },

<span id='Ext-chart-interactions-Crosshair-method-onGestureStart'>    onGestureStart: function (e) {
</span>        var me = this,
            chart = me.getChart(),
            surface = chart.getSurface(&#39;overlay-surface&#39;),
            region = chart.getInnerRegion(),
            chartWidth = region[2],
            chartHeight = region[3],
            xy = chart.element.getXY(),
            x = e.pageX - xy[0] - region[0],
            y = e.pageY - xy[1] - region[1],
            axes = chart.getAxes(),
            axesConfig = me.getAxes(),
            linesConfig = me.getLines(),
            axis, axisSurface, axisRegion, axisWidth, axisHeight, axisPosition,
            axisLabel, labelPadding,
            axisSprite, attr, axisThickness, lineWidth, halfLineWidth,
            i;

        if (x &gt; 0 &amp;&amp; x &lt; chartWidth &amp;&amp; y &gt; 0 &amp;&amp; y &lt; chartHeight) {
            me.lockEvents(me.getGesture());
            me.horizontalLine = surface.add(Ext.apply({
                xclass: &#39;Ext.chart.grid.HorizontalGrid&#39;,
                x: 0,
                y: y,
                width: chartWidth
            }, linesConfig.horizontal));
            me.verticalLine = surface.add(Ext.apply({
                xclass: &#39;Ext.chart.grid.VerticalGrid&#39;,
                x: x,
                y: 0,
                height: chartHeight
            }, linesConfig.vertical));
            me.axesLabels = me.axesLabels || {};
            for (i = 0; i &lt; axes.length; i++) {
                axis = axes[i];
                axisSurface = axis.getSurface();
                axisRegion = axisSurface.getRegion();
                axisSprite = axis.getSprites()[0];
                axisWidth = axisRegion[2];
                axisHeight = axisRegion[3];
                axisPosition = axis.getPosition();
                attr = axisSprite.attr;
                axisThickness = axisSprite.thickness;
                lineWidth = attr.axisLine ? attr.lineWidth : 0;
                halfLineWidth = lineWidth / 2;
                labelPadding = Math.max(attr.majorTickSize, attr.minorTickSize) + lineWidth;

                axisLabel = me.axesLabels[axisPosition] = axisSurface.add({type: &#39;composite&#39;});
                axisLabel.labelRect = axisLabel.add(Ext.apply({
                    type: &#39;rect&#39;,
                    fillStyle: &#39;white&#39;,
                    x: axisPosition === &#39;right&#39; ? lineWidth : axisSurface.roundPixel(axisWidth - axisThickness - labelPadding) - halfLineWidth,
                    y: axisPosition === &#39;bottom&#39; ? lineWidth : axisSurface.roundPixel(axisHeight - axisThickness - labelPadding) - lineWidth,
                    width: axisPosition === &#39;left&#39; ? axisThickness - halfLineWidth + labelPadding : axisThickness + labelPadding,
                    height: axisPosition === &#39;top&#39; ? axisThickness + labelPadding : axisThickness + labelPadding
                }, axesConfig.rect || axesConfig[axisPosition].rect));
                axisLabel.labelText = axisLabel.add(Ext.apply(Ext.Object.chain(axis.config.label), axesConfig.label || axesConfig[axisPosition].label, {
                    type: &#39;text&#39;,
                    x: (function () {
                        switch (axisPosition) {
                            case &#39;left&#39;:
                                return axisWidth - labelPadding - halfLineWidth - axisThickness / 2;
                            case &#39;right&#39;:
                                return axisThickness / 2 + labelPadding - halfLineWidth;
                            default:
                                return 0;
                        }
                    })(),
                    y: (function () {
                        switch (axisPosition) {
                            case &#39;top&#39;:
                                return axisHeight - labelPadding - halfLineWidth - axisThickness / 2;
                            case &#39;bottom&#39;:
                                return axisThickness / 2 + labelPadding;
                            default:
                                return 0;
                        }
                    })()
                }));
            }
            return false;
        }

    },

<span id='Ext-chart-interactions-Crosshair-method-onGesture'>    onGesture: function (e) {
</span>        var me = this;
        if (me.getLocks()[me.getGesture()] !== me) {
            return;
        }
        var chart = me.getChart(),
            surface = chart.getSurface(&#39;overlay-surface&#39;),
            region = Ext.Array.slice(chart.getInnerRegion()),
            padding = chart.getInnerPadding(),
            px = padding.left,
            py = padding.top,
            chartWidth = region[2],
            chartHeight = region[3],
            xy = chart.element.getXY(),
            x = e.pageX - xy[0] - region[0],
            y = e.pageY - xy[1] - region[1],
            axes = chart.getAxes(),
            axis, axisPosition, axisAlignment, axisSurface, axisSprite, axisMatrix,
            axisLayoutContext, axisSegmenter,
            axisLabel, labelBBox, textPadding,
            xx, yy, dx, dy,
            xValue, yValue,
            text,
            i;

        if (x &lt; 0) {
            x = 0;
        } else if (x &gt; chartWidth) {
            x = chartWidth;
        }
        if (y &lt; 0) {
            y = 0;
        } else if (y &gt; chartHeight) {
            y = chartHeight;
        }
        x += px;
        y += py;

        for (i = 0; i &lt; axes.length; i++) {
            axis = axes[i];
            axisPosition = axis.getPosition();
            axisAlignment = axis.getAlignment();
            axisSurface = axis.getSurface();
            axisSprite = axis.getSprites()[0];
            axisMatrix = axisSprite.attr.matrix;
            textPadding = axisSprite.attr.textPadding * 2;
            axisLabel = me.axesLabels[axisPosition];
            axisLayoutContext = axisSprite.getLayoutContext();
            axisSegmenter = axis.getSegmenter();

            if (axisLabel) {
                if (axisAlignment === &#39;vertical&#39;) {
                    yy = axisMatrix.getYY();
                    dy = axisMatrix.getDY();
                    yValue = (y - dy - py) / yy;
                    if (axis.getLayout() instanceof Ext.chart.axis.layout.Discrete) {
                        y = Math.round(yValue) * yy + dy + py;
                        yValue = axisSegmenter.from(Math.round(yValue));
                        yValue = axisSprite.attr.data[yValue];
                    } else {
                        yValue = axisSegmenter.from(yValue);
                    }
                    text = axisSegmenter.renderer(yValue, axisLayoutContext);

                    axisLabel.setAttributes({translationY: y - py});
                    axisLabel.labelText.setAttributes({text: text});
                    labelBBox = axisLabel.labelText.getBBox();
                    axisLabel.labelRect.setAttributes({
                        height: labelBBox.height + textPadding,
                        y: -(labelBBox.height + textPadding) / 2
                    });
                    axisSurface.renderFrame();
                } else {
                    xx = axisMatrix.getXX();
                    dx = axisMatrix.getDX();
                    xValue = (x - dx - px) / xx;
                    if (axis.getLayout() instanceof Ext.chart.axis.layout.Discrete) {
                        x = Math.round(xValue) * xx + dx + px;
                        xValue = axisSegmenter.from(Math.round(xValue));
                        xValue = axisSprite.attr.data[xValue];
                    } else {
                        xValue = axisSegmenter.from(xValue);
                    }
                    text = axisSegmenter.renderer(xValue, axisLayoutContext);

                    axisLabel.setAttributes({translationX: x - px});
                    axisLabel.labelText.setAttributes({text: text});
                    labelBBox = axisLabel.labelText.getBBox();
                    axisLabel.labelRect.setAttributes({
                        width: labelBBox.width + textPadding,
                        x: -(labelBBox.width + textPadding) / 2
                    });
                    axisSurface.renderFrame();
                }
            }
        }
        me.horizontalLine.setAttributes({y: y});
        me.verticalLine.setAttributes({x: x});
        surface.renderFrame();
        return false;
    },

<span id='Ext-chart-interactions-Crosshair-method-onGestureEnd'>    onGestureEnd: function (e) {
</span>        var me = this,
            chart = me.getChart(),
            surface =  chart.getSurface(&#39;overlay-surface&#39;),
            axes = chart.getAxes(),
            axis, axisPosition, axisSurface, axisLabel,
            i;

        surface.remove(me.verticalLine);
        surface.remove(me.horizontalLine);

        for (i = 0; i &lt; axes.length; i++) {
            axis = axes[i];
            axisPosition = axis.getPosition();
            axisSurface = axis.getSurface();
            axisLabel = me.axesLabels[axisPosition];
            if (axisLabel) {
                delete me.axesLabels[axisPosition];
                axisSurface.remove(axisLabel);
            }
            axisSurface.renderFrame();
        }

        surface.renderFrame();
        me.unlockEvents(me.getGesture());
    }

})</pre>
</body>
</html>
