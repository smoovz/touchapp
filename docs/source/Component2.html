<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-draw-Component'>/**
</span> * The Draw Component is a surface in which sprites can be rendered. The Draw Component
 * manages and holds a `Surface` instance: an interface that has
 * an SVG or VML implementation depending on the browser capabilities and where
 * Sprites can be appended.
 * One way to create a draw component is:
 *
 *     var drawComponent = new Ext.draw.Component({
 *         items: [{
 *             type: &#39;circle&#39;,
 *             fill: &#39;#79BB3F&#39;,
 *             radius: 100,
 *             x: 100,
 *             y: 100
 *         }]
 *     });
 *
 *     new Ext.Panel({
 *         fullscreen: true,
 *         items: [drawComponent]
 *     });
 *
 * In this case we created a draw component and added a sprite to it.
 * The *type* of the sprite is *circle* so if you run this code you&#39;ll see a yellow-ish
 * circle in a Window. When setting `viewBox` to `false` we are responsible for setting the object&#39;s position and
 * dimensions accordingly.
 *
 * You can also add sprites by using the surface&#39;s add method:
 *
 *     drawComponent.getSurface(&#39;main&#39;).add({
 *         type: &#39;circle&#39;,
 *         fill: &#39;#79BB3F&#39;,
 *         radius: 100,
 *         x: 100,
 *         y: 100
 *     });
 *
 * For more information on Sprites, the core elements added to a draw component&#39;s surface,
 * refer to the {@link Ext.draw.sprite.Sprite} documentation.
 */
Ext.define(&#39;Ext.draw.Component&#39;, {

    extend: &#39;Ext.Container&#39;,
    xtype: &#39;draw&#39;,
<span id='Ext-draw-Component-cfg-defaultType'>    defaultType: &#39;surface&#39;,
</span>
    requires: [
        &#39;Ext.draw.Surface&#39;,
        &#39;Ext.draw.engine.Svg&#39;,
        &#39;Ext.draw.engine.Canvas&#39;,
        &#39;Ext.draw.sprite.GradientDefinition&#39;
    ],
<span id='Ext-draw-Component-property-engine'>    engine: &#39;Ext.draw.engine.Canvas&#39;,
</span>    statics: {
<span id='Ext-draw-Component-static-property-WATERMARK'>        WATERMARK: &#39;Powered by &lt;span style=&quot;color:#22E962; font-weight: 900&quot;&gt;Sencha Touch&lt;/span&gt; &lt;span style=&quot;color:#75cdff; font-weight: 900&quot;&gt;GPLv3&lt;/span&gt;&#39;
</span>    },
    config: {
<span id='Ext-draw-Component-cfg-cls'>        cls: &#39;x-draw-component&#39;,
</span>
<span id='Ext-draw-Component-cfg-autoSize'>        /**
</span>         * @deprecated 2.2.0 Please implement custom resize event handler.
         * Resize the draw component by the content size of the main surface.
         *
         * __Note:__ It is applied only when there is only one surface.
         */
        autoSize: false,

<span id='Ext-draw-Component-cfg-viewBox'>        /**
</span>         * @deprecated 2.2.0 Please implement custom resize event handler.
         * Pan/Zoom the content in main surface to fit the component size.
         *
         * __Note:__ It is applied only when there is only one surface.
         */
        viewBox: false,

<span id='Ext-draw-Component-cfg-fitSurface'>        /**
</span>         * @deprecated 2.2.0 Please implement custom resize event handler.
         * Fit the main surface to the size of component.
         *
         * __Note:__ It is applied only when there is only one surface.
         */
        fitSurface: true,

<span id='Ext-draw-Component-cfg-resizeHandler'>        /**
</span>         * @cfg {Function} [resizeHandler] The resize function that can be configured to have a behavior.
         */
        resizeHandler: null,

<span id='Ext-draw-Component-cfg-background'>        background: null,
</span>
<span id='Ext-draw-Component-cfg-sprites'>        sprites: null,
</span>
<span id='Ext-draw-Component-cfg-gradients'>        /**
</span>         * @cfg {Object[]} gradients
         * Defines a set of gradients that can be used as color properties
         * (fillStyle and strokeStyle, but not shadowColor) in sprites.
         * The gradients array is an array of objects with the following properties:
         * - **id** - string - The unique name of the gradient.
         * - **type** - string, optional - The type of the gradient. Available types are: &#39;linear&#39;, &#39;radial&#39;. Defaults to &#39;linear&#39;.
         * - **angle** - number, optional - The angle of the gradient in degrees.
         * - **stops** - array - An array of objects with &#39;color&#39; and &#39;offset&#39; properties, where &#39;offset&#39; is a real number from 0 to 1.
         *
         * For example:
         *
         *     gradients: [{
         *         id: &#39;gradientId1&#39;,
         *         type: &#39;linear&#39;,
         *         angle: 45,
         *         stops: [{
         *             offset: 0,
         *             color: &#39;red&#39;
         *         }, {
         *            offset: 1,
         *            color: &#39;yellow&#39;
         *         }]
         *     }, {
         *        id: &#39;gradientId2&#39;,
         *        type: &#39;radial&#39;,
         *        stops: [{
         *            offset: 0,
         *            color: &#39;#555&#39;,
         *        }, {
         *            offset: 1,
         *            color: &#39;#ddd&#39;,
         *        }]
         *     }]
         *
         * Then the sprites can use &#39;gradientId1&#39; and &#39;gradientId2&#39; by setting the color attributes to those ids, for example:
         *
         *     sprite.setAttributes({
         *         fillStyle: &#39;url(#gradientId1)&#39;,
         *         strokeStyle: &#39;url(#gradientId2)&#39;
         *     });
         */
        gradients: []
    },

<span id='Ext-draw-Component-method-constructor'>    constructor: function (config) {
</span>        config = config || {};
        this.callSuper(arguments);
        this.frameCallbackId = Ext.draw.Animator.addFrameCallback(&#39;renderFrame&#39;, this);
    },

<span id='Ext-draw-Component-method-applyGradients'>    applyGradients: function (gradients) {
</span>        var result = [],
            i, n, gradient;
        if (!Ext.isArray(gradients)) {
            return result;
        }
        for (i = 0, n = gradients.length; i &lt; n; i++) {
            gradient = gradients[i];
            if (!Ext.isObject(gradient)) {
                continue;
            }
            // ExtJS only supported linear gradients, so we didn&#39;t have to specify their type
            if (typeof gradient.type !== &#39;string&#39;) {
                gradient.type = &#39;linear&#39;;
            }
            if (gradient.angle) {
                gradient.degrees = gradient.angle;
                delete gradient.angle;
            }
            // Convert ExtJS stops object to Touch stops array
            if (Ext.isObject(gradient.stops)) {
                gradient.stops = (function (stops) {
                    var result = [], stop;
                    for (offset in stops) {
                        stop = stops[offset];
                        stop.offset = offset / 100;
                        result.push(stop);
                    }
                    return result;
                })(gradient.stops);
            }
            result.push(gradient);
        }
        Ext.draw.sprite.GradientDefinition.add(result);
        return result;
    },

<span id='Ext-draw-Component-method-initialize'>    initialize: function () {
</span>        var me = this;
        me.callSuper();
        me.element.on(&#39;resize&#39;, &#39;onResize&#39;, this);
    },

<span id='Ext-draw-Component-method-applySprites'>    applySprites: function (sprites) {
</span>        // Never update
        if (!sprites) {
            return;
        }

        sprites = Ext.Array.from(sprites);

        var ln = sprites.length,
            i, surface;

        for (i = 0; i &lt; ln; i++) {
            if (sprites[i].surface instanceof Ext.draw.Surface) {
                surface = sprites[i].surface;
            } else if (Ext.isString(sprites[i].surface)) {
                surface = this.getSurface(sprites[i].surface);
            } else {
                surface = this.getSurface(&#39;main&#39;);
            }
            surface.add(sprites[i]);
        }
    },

<span id='Ext-draw-Component-method-getElementConfig'>    getElementConfig: function () {
</span>        return {
            reference: &#39;element&#39;,
            className: &#39;x-container&#39;,
            children: [
                {
                    reference: &#39;innerElement&#39;,
                    className: &#39;x-inner&#39;,
                    children: [
                        {
                            reference: &#39;watermarkElement&#39;,
                            cls: &#39;x-chart-watermark&#39;,
                            html: Ext.draw.Component.WATERMARK,
                            style: Ext.draw.Component.WATERMARK ? &#39;&#39;: &#39;display: none&#39;
                        }
                    ]
                }
            ]
        };
    },

<span id='Ext-draw-Component-method-updateBackground'>    updateBackground: function (background) {
</span>        this.element.setStyle({
            background: background
        });
    },

<span id='Ext-draw-Component-method-onPlaceWatermark'>    /**
</span>     * @protected
     * Place water mark after resize.
     */
    onPlaceWatermark: function () {
        // Do nothing
    },

<span id='Ext-draw-Component-method-onResize'>    onResize: function () {
</span>        var me = this,
            size = me.element.getSize();
        me.fireEvent(&#39;resize&#39;, me, size);
        if (me.getResizeHandler()) {
            me.getResizeHandler().call(me, size);
        } else {
            me.resizeHandler(size);
        }
        me.renderFrame();
        me.onPlaceWatermark();
    },

<span id='Ext-draw-Component-method-resizeHandler'>    resizeHandler: function (size) {
</span>        var me = this;

        //&lt;deprecated product=touch since=2.2&gt;
        var surfaces = me.getItems(),
            surface, bbox, mat, zoomX, zoomY, zoom;

        if (surfaces.length === 1) {
            surface = surfaces.get(0);
            if (me.getAutoSize()) {
                bbox = surface.getItems().getBBox();
                mat = new Ext.draw.Matrix();
                mat.prepend(1, 0, 0, 1, -bbox.x, -bbox.y);
                surface.matrix = mat;
                surface.inverseMatrix = mat.inverse();
                surface.setRegion([0, 0, bbox.width, bbox.height]);
            } else if (me.getViewBox()) {
                bbox = surface.getItems().getBBox();
                zoomX = size.width / bbox.width;
                zoomY = size.height / bbox.height;
                zoom = Math.min(zoomX, zoomY);
                mat = new Ext.draw.Matrix();
                mat.prepend(
                    zoom, 0, 0, zoom,
                    size.width * 0.5 + (-bbox.x - bbox.width * 0.5) * zoom,
                    size.height * 0.5 + (-bbox.y - bbox.height * 0.5) * zoom);
                surface.matrix = mat;
                surface.inverseMatrix = mat.inverse();
                surface.setRegion([0, 0, size.width, size.height]);
            } else if (me.getFitSurface()) {
                surface.setRegion([0, 0, size.width, size.height]);
            }
        } else if (!me.getFitSurface()) {
            return;
        }
        //&lt;/deprecated&gt;

        me.getItems().each(function (surface) {
            surface.setRegion([0, 0, size.width, size.height]);
        });
    },

<span id='Ext-draw-Component-method-getSurface'>    /**
</span>     * Get a surface by the given id or create one if it doesn&#39;t exist.
     * @param {String} [id=&quot;main&quot;]
     * @return {Ext.draw.Surface}
     */
    getSurface: function (id) {
        id = this.getId() + &#39;-&#39; + (id || &#39;main&#39;);
        var me = this,
            surfaces = me.getItems(),
            surface = surfaces.get(id),
            size;

        if (!surface) {
            surface = me.add({xclass: me.engine, id: id});
            if (me.getFitSurface()) {
                size = me.element.getSize();
                surface.setRegion([0, 0, size.width, size.height]);
            }
            surface.renderFrame();
        }
        return surface;
    },

<span id='Ext-draw-Component-method-renderFrame'>    /**
</span>     * Render all the surfaces in the component.
     */
    renderFrame: function () {
        var me = this,
            i, ln, bbox,
            surfaces = me.getItems();

        for (i = 0, ln = surfaces.length; i &lt; ln; i++) {
            surfaces.items[i].renderFrame();
        }
        //&lt;deprecated product=touch since=2.2&gt;
        // TODO: Throw a deprecation message
        if (surfaces.length === 1 &amp;&amp; me.getAutoSize()) {
            bbox = me.getSurface().getItems().getBBox();
            me.setSize(Math.ceil(bbox.width) + 1, Math.ceil(bbox.height) + 1);
        }
        //&lt;/deprecated&gt;
    },

<span id='Ext-draw-Component-method-destroy'>    destroy: function () {
</span>        Ext.draw.Animator.removeFrameCallback(this.frameCallbackId);
        this.callSuper();
    }
}, function () {
    if (location.search.match(&#39;svg&#39;)) {
        Ext.draw.Component.prototype.engine = &#39;Ext.draw.engine.Svg&#39;;
    } else if ((Ext.os.is.BlackBerry &amp;&amp; Ext.os.version.getMajor() === 10) || (Ext.browser.is.AndroidStock4 &amp;&amp; (Ext.os.version.getMinor() === 1 || Ext.os.version.getMinor() === 2 || Ext.os.version.getMinor() === 3))) {
        // http://code.google.com/p/android/issues/detail?id=37529
        Ext.draw.Component.prototype.engine = &#39;Ext.draw.engine.Svg&#39;;
    }
});
</pre>
</body>
</html>
