<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-chart-axis-layout-Discrete'>/**
</span> * @class Ext.chart.axis.layout.Discrete
 * @extends Ext.chart.axis.layout.Layout
 *
 * Simple processor for data that cannot be interpolated.
 */
Ext.define(&#39;Ext.chart.axis.layout.Discrete&#39;, {
    extend: &#39;Ext.chart.axis.layout.Layout&#39;,
    alias: &#39;axisLayout.discrete&#39;,

<span id='Ext-chart-axis-layout-Discrete-method-processData'>    processData: function () {
</span>        var me = this,
            axis = me.getAxis(),
            boundSeries = axis.boundSeries,
            direction = axis.getDirection(),
            i, ln, item;
        this.labels = [];
        this.labelMap = {};
        for (i = 0, ln = boundSeries.length; i &lt; ln; i++) {
            item = boundSeries[i];
            if (item[&#39;get&#39; + direction + &#39;Axis&#39;]() === axis) {
                item[&#39;coordinate&#39; + direction]();
            }
        }
        // About the labels on Category axes (aka. axes with a Discrete layout)...
        //
        // When the data set from the store changes, series.processData() is called, which does its thing
        // at the series level and then calls series.updateLabelData() to update the labels in the sprites
        // that belong to the series. At the same time, series.processData() calls axis.processData(), which
        // also does its thing but at the axis level, and also needs to update the labels for the sprite(s)
        // that belong to the axis. This is not that simple, however. So how are the axis labels rendered?
        // First, axis.sprite.Axis.render() calls renderLabels() which obtains the majorTicks from the 
        // axis.layout and iterate() through them. The majorTicks are an object returned by snapEnds() below
        // which provides a getLabel() function that returns the label from the axis.layoutContext.data array.
        // So now the question is: how are the labels transferred from the axis.layout to the axis.layoutContext?
        // The easy response is: it&#39;s in calculateLayout() below. The issue is to call calculateLayout() because
        // it takes in an axis.layoutContext that can only be created in axis.sprite.Axis.doLayout(), which is 
        // a private &quot;updater&quot; function that is called by all the sprite&#39;s &quot;dirtyTriggers&quot;. Of course, we don&#39;t 
        // want to call doLayout() directly from here, so instead we update the sprite&#39;s data attribute, which 
        // sets the dirtyTrigger which calls doLayout() which calls calculateLayout() etc...
        // Note that the sprite&#39;s data attribute could be set to any value and it would still result in the  
        // dirtyTrigger we need. For consistency, however, it is set to the labels.
        axis.getSprites()[0].setAttributes({data:this.labels});
    },

<span id='Ext-chart-axis-layout-Discrete-method-calculateLayout'>    // @inheritdoc
</span>    calculateLayout: function (context) {
        context.data = this.labels;
        this.callSuper([context]);
    },

<span id='Ext-chart-axis-layout-Discrete-method-calculateMajorTicks'>    //@inheritdoc
</span>    calculateMajorTicks: function (context) {
        var me = this,
            attr = context.attr,
            data = context.data,
            range = attr.max - attr.min,
            zoom = range / Math.max(1, attr.length) * (attr.visibleMax - attr.visibleMin),
            viewMin = attr.min + range * attr.visibleMin,
            viewMax = attr.min + range * attr.visibleMax,
            estStepSize = attr.estStepSize * zoom;

        var out = me.snapEnds(context, Math.max(0, attr.min), Math.min(attr.max, data.length - 1), estStepSize);
        if (out) {
            me.trimByRange(context, out, viewMin, viewMax);
            context.majorTicks = out;
        }
    },

<span id='Ext-chart-axis-layout-Discrete-method-snapEnds'>    // @inheritdoc
</span>    snapEnds: function (context, min, max, estStepSize) {
        estStepSize = Math.ceil(estStepSize);
        var steps = Math.floor((max - min) / estStepSize),
            data = context.data;
        return {
            min: min,
            max: max,
            from: min,
            to: steps * estStepSize + min,
            step: estStepSize,
            steps: steps,
            unit: 1,
            getLabel: function (current) {
                return data[this.from + this.step * current];
            },
            get: function (current) {
                return this.from + this.step * current;
            }
        };
    },

<span id='Ext-chart-axis-layout-Discrete-method-trimByRange'>    // @inheritdoc
</span>    trimByRange: function (context, out, trimMin, trimMax) {
        var unit = out.unit,
            beginIdx = Math.ceil((trimMin - out.from) / unit) * unit,
            endIdx = Math.floor((trimMax - out.from) / unit) * unit,
            begin = Math.max(0, Math.ceil(beginIdx / out.step)),
            end = Math.min(out.steps, Math.floor(endIdx / out.step));

        if (end &lt; out.steps) {
            out.to = end;
        }

        if (out.max &gt; trimMax) {
            out.max = out.to;
        }

        if (out.from &lt; trimMin &amp;&amp; out.step &gt; 0) {
            out.from = out.from + begin * out.step * unit;
            while (out.from &lt; trimMin) {
                begin++;
                out.from += out.step * unit;
            }
        }

        if (out.min &lt; trimMin) {
            out.min = out.from;
        }

        out.steps = end - begin;
    },

<span id='Ext-chart-axis-layout-Discrete-method-getCoordFor'>    getCoordFor: function (value, field, idx, items) {
</span>        this.labels.push(value);
        return this.labels.length - 1;
    }
});</pre>
</body>
</html>
