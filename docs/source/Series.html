<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-chart-series-Series'>/**
</span> * Series is the abstract class containing the common logic to all chart series. Series includes
 * methods from Labels, Highlights, and Callouts mixins. This class implements the logic of
 * animating, hiding, showing all elements and returning the color of the series to be used as a legend item.
 *
 * ## Listeners
 *
 * The series class supports listeners via the Observable syntax. Some of these listeners are:
 *
 *  - `itemmouseup` When the user interacts with a marker.
 *  - `itemmousedown` When the user interacts with a marker.
 *  - `itemmousemove` When the user interacts with a marker.
 *  - (similar `item*` events occur for many raw mouse and touch events)
 *  - `afterrender` Will be triggered when the animation ends or when the series has been rendered completely.
 *
 * For example:
 *
 *     series: [{
 *         type: &#39;bar&#39;,
 *         axis: &#39;left&#39;,
 *         listeners: {
 *             &#39;afterrender&#39;: function() {
 *                 console(&#39;afterrender&#39;);
 *             }
 *         },
 *         xField: &#39;category&#39;,
 *         yField: &#39;data1&#39;
 *     }]
 *
 */
Ext.define(&#39;Ext.chart.series.Series&#39;, {

    requires: [&#39;Ext.chart.Markers&#39;, &#39;Ext.chart.label.Label&#39;],

    mixins: {
        observable: &#39;Ext.mixin.Observable&#39;
    },

<span id='Ext-chart-series-Series-property-type'>    /**
</span>     * @property {String} type
     * The type of series. Set in subclasses.
     * @protected
     */
    type: null,

<span id='Ext-chart-series-Series-property-seriesType'>    /**
</span>     * @property {String} seriesType
     * Default series sprite type.
     */
    seriesType: &#39;sprite&#39;,

<span id='Ext-chart-series-Series-property-identifiablePrefix'>    identifiablePrefix: &#39;ext-line-&#39;,
</span>
<span id='Ext-chart-series-Series-property-observableType'>    observableType: &#39;series&#39;,
</span>
<span id='Ext-chart-series-Series-event-chartattached'>    /**
</span>     * @event chartattached
     * Fires when the {@link Ext.chart.AbstractChart} has been attached to this series.
     * @param {Ext.chart.AbstractChart} chart
     * @param {Ext.chart.series.Series} series
     */
<span id='Ext-chart-series-Series-event-chartdetached'>    /**
</span>     * @event chartdetached
     * Fires when the {@link Ext.chart.AbstractChart} has been detached from this series.
     * @param {Ext.chart.AbstractChart} chart
     * @param {Ext.chart.series.Series} series
     */

    config: {
<span id='Ext-chart-series-Series-cfg-chart'>        /**
</span>         * @private
         * @cfg {Object} chart The chart that the series is bound.
         */
        chart: null,

<span id='Ext-chart-series-Series-cfg-title'>        /**
</span>         * @cfg {String} title
         * The human-readable name of the series.
         */
        title: null,

<span id='Ext-chart-series-Series-cfg-renderer'>        /**
</span>         * @cfg {Function} renderer
         * A function that can be provided to set custom styling properties to each rendered element.
         * It receives `(sprite, config, rendererData, index)` as parameters.
         *
         * @param {Object} sprite The sprite affected by the renderer. The visual attributes are in `sprite.attr`.
         * The data field is available in `sprite.getField()`.
         * @param {Object} config The sprite configuration. It varies with the series and the type of sprite:
         * for instance, a Line chart sprite might have just the `x` and `y` properties while a Bar
         * chart sprite also has `width` and `height`. A `type` might be present too. For instance to
         * draw each marker and each segment of a Line chart, the renderer is called with the
         * `config.type` set to either `marker` or `line`.
         * @param {Object} rendererData A record with different properties depending on the type of chart.
         * The only guaranteed property is `rendererData.store`, the store used by the series.
         * In some cases, a store may not exist: for instance a Gauge chart may read its value directly
         * from its configuration; in this case rendererData.store is null and the value is
         * available in rendererData.value.
         * @param {Number} index The index of the sprite. It is usually the index of the store record associated
         * with the sprite, in which case the record can be obtained with `store.getData().items[index]`.
         * If the chart is not associated with a store, the index represents the index of the sprite within
         * the series. For instance a Gauge chart may have as many sprites as there are sectors in the
         * background of the gauge, plus one for the needle.
         *
         * @return {Object} The attributes that have been changed or added. Note: it is usually possible to
         * add or modify the attributes directly into the `config` parameter and not return anything,
         * but returning an object with only those attributes that have been changed may allow for
         * optimizations in the rendering of some series. Example to draw every other item in red:
         *
         *      renderer: function (sprite, config, rendererData, index) {
         *          if (index % 2 == 0) {
         *              return { strokeStyle: &#39;red&#39; };
         *          }
         *      }
         */
        renderer: null,

<span id='Ext-chart-series-Series-cfg-showInLegend'>        /**
</span>         * @cfg {Boolean} showInLegend
         * Whether to show this series in the legend.
         */
        showInLegend: true,

<span id='Ext-chart-series-Series-cfg-triggerAfterDraw'>        //@private triggerdrawlistener flag
</span>        triggerAfterDraw: false,

<span id='Ext-chart-series-Series-cfg-themeStyle'>        /**
</span>         * @private
         * Not supported.
         */
        themeStyle: {},

<span id='Ext-chart-series-Series-cfg-style'>        /**
</span>         * @cfg {Object} style Custom style configuration for the sprite used in the series.
         */
        style: {},

<span id='Ext-chart-series-Series-cfg-subStyle'>        /**
</span>         * @cfg {Object} subStyle This is the cyclic used if the series has multiple sprites.
         */
        subStyle: {},

<span id='Ext-chart-series-Series-cfg-colors'>        /**
</span>         * @cfg {Array} colors
         * An array of color values which will be used, in order, as the pie slice fill colors.
         */
        colors: null,

<span id='Ext-chart-series-Series-cfg-store'>        /**
</span>         * @protected
         * @cfg {Object} store The store of values used in the series.
         */
        store: null,

<span id='Ext-chart-series-Series-cfg-label'>        /**
</span>         * @cfg {Object} label
         * The style object for labels.
         */

<span id='Ext-chart-series-Series-cfg-label'>        /**
</span>         * @cfg {Object} label
         * Object with the following properties:
         *
         * @cfg {String} label.display
         *
         * Specifies the presence and position of the labels. The possible values depend on the chart type.
         * For Line charts: &#39;under&#39; | &#39;over&#39; | &#39;rotate&#39;.
         * For Bar charts: &#39;insideStart&#39; | &#39;insideEnd&#39; | &#39;outside&#39;.
         * For Pie charts: &#39;outside&#39; | &#39;rotate&#39;.
         * For all charts: &#39;none&#39; hides the labels.
         *
         * Default value: &#39;none&#39;.
         *
         * @cfg {String} label.color
         *
         * The color of the label text.
         *
         * Default value: &#39;#000&#39; (black).
         *
         * @cfg {String|String[]} label.field
         *
         * The name(s) of the field(s) to be displayed in the labels. If your chart has 3 series
         * that correspond to the fields &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; of your model and you only want to
         * display labels for the series &#39;c&#39;, you must still provide an array `[null, null, &#39;c&#39;]`.
         *
         * Default value: null.
         *
         * @cfg {String} label.font
         *
         * The font used for the labels.
         *
         * Default value: &#39;14px Helvetica&#39;.
         *
         * @cfg {String} label.orientation
         *
         * Either &#39;horizontal&#39; or &#39;vertical&#39;. If not set (default), the orientation is inferred
         * from the value of the flipXY property of the series.
         *
         * Default value: &#39;&#39;.
         *
         * @cfg {Function} label.renderer
         *
         * Optional function for formatting the label into a displayable value.
         *
         * The arguments to the method are:
         *
         *   - *`text`*, *`sprite`*, *`config`*, *`rendererData`*, *`index`*
         *
         *     Label&#39;s renderer is passed the same arguments as {@link #renderer}
         *     plus one extra &#39;text&#39; argument which comes first.
         *
         * @return {Object/String} The attributes that have been changed or added, or the text for the label.
         * Example to enclose every other label in parentheses:
         *
         *      renderer: function (text) {
         *          if (index % 2 == 0) {
         *              return &#39;(&#39; + text + &#39;)&#39;
         *          }
         *      }
         *
         * Default value: null.
         */
        label: {textBaseline: &#39;middle&#39;, textAlign: &#39;center&#39;, font: &#39;14px Helvetica&#39;},

<span id='Ext-chart-series-Series-cfg-labelOverflowPadding'>        /**
</span>         * @cfg {Number} labelOverflowPadding
         * Extra distance value for which the labelOverflow listener is triggered.
         */
        labelOverflowPadding: 5,

<span id='Ext-chart-series-Series-cfg-labelField'>        /**
</span>         * @cfg {String/String[]} labelField
         * @deprecated Use &#39;field&#39; property of {@link Ext.chart.series.Series#label} instead.
         * The store record field name to be used for the series labels.
         */
        labelField: null,

<span id='Ext-chart-series-Series-cfg-marker'>        /**
</span>         * @cfg {Object} marker
         * The sprite template used by marker instances on the series.
         */
        marker: null,

<span id='Ext-chart-series-Series-cfg-markerSubStyle'>        /**
</span>         * @cfg {Object} markerSubStyle
         * This is cyclic used if series have multiple marker sprites.
         */
        markerSubStyle: null,

<span id='Ext-chart-series-Series-cfg-itemInstancing'>        /**
</span>         * @protected
         * @cfg {Object} itemInstancing The sprite template used to create sprite instances in the series.
         */
        itemInstancing: null,

<span id='Ext-chart-series-Series-cfg-background'>        /**
</span>         * @cfg {Object} background Sets the background of the surface the series is attached.
         */
        background: null,

<span id='Ext-chart-series-Series-cfg-highlightItem'>        /**
</span>         * @cfg {Object} highlightItem The item currently highlighted in the series.
         */
        highlightItem: null,

<span id='Ext-chart-series-Series-cfg-surface'>        /**
</span>         * @protected
         * @cfg {Object} surface The surface that the series is attached.
         */
        surface: null,

<span id='Ext-chart-series-Series-cfg-overlaySurface'>        /**
</span>         * @protected
         * @cfg {Object} overlaySurface The surface that series markers are attached.
         */
        overlaySurface: null,

<span id='Ext-chart-series-Series-cfg-hidden'>        /**
</span>         * @cfg {Boolean|Array} hidden
         */
        hidden: false,

<span id='Ext-chart-series-Series-cfg-highlightCfg'>        /**
</span>         * @cfg {Object} highlightCfg The sprite configuration used when highlighting items in the series.
         */
        highlightCfg: null,

<span id='Ext-chart-series-Series-cfg-animate'>        /**
</span>         * @cfg {Object} animate The series animation configuration.
         */
        animate: null
    },

<span id='Ext-chart-series-Series-property-directions'>    directions: [],
</span>
<span id='Ext-chart-series-Series-property-sprites'>    sprites: null,
</span>
<span id='Ext-chart-series-Series-method-getFields'>    getFields: function (fieldCategory) {
</span>        var me = this,
            fields = [], fieldsItem,
            i, ln;
        for (i = 0, ln = fieldCategory.length; i &lt; ln; i++) {
            fieldsItem = me[&#39;get&#39; + fieldCategory[i] + &#39;Field&#39;]();
            fields.push(fieldsItem);
        }
        return fields;
    },

<span id='Ext-chart-series-Series-method-updateAnimate'>    updateAnimate: function (animate) {
</span>        var sprites = this.getSprites(), i = -1, ln = sprites.length;
        while (++i &lt; ln) {
            sprites[i].fx.setConfig(animate);
        }
    },

<span id='Ext-chart-series-Series-method-updateTitle'>    updateTitle: function (newTitle) {
</span>        if (newTitle) {
            var chart = this.getChart(),
                series = chart.getSeries(),
                legendStore = chart.getLegendStore(),
                index, rec;

            if (series) {
                index = Ext.Array.indexOf(series, this);

                if (index !== -1) {
                    rec = legendStore.getAt(index);
                    rec.set(&#39;name&#39;, newTitle);
                }
            }
        }
    },

<span id='Ext-chart-series-Series-method-updateColors'>    updateColors: function (colorSet) {
</span>        this.setSubStyle({fillStyle: colorSet});
        this.doUpdateStyles();
    },

<span id='Ext-chart-series-Series-method-applyHighlightCfg'>    applyHighlightCfg: function (highlight, oldHighlight) {
</span>        return Ext.apply(oldHighlight || {}, highlight);
    },

<span id='Ext-chart-series-Series-method-applyItemInstancing'>    applyItemInstancing: function (instancing, oldInstancing) {
</span>        return Ext.merge(oldInstancing || {}, instancing);
    },

<span id='Ext-chart-series-Series-method-setAttributesForItem'>    setAttributesForItem: function (item, change) {
</span>        if (item &amp;&amp; item.sprite) {
            if (item.sprite.itemsMarker &amp;&amp; item.category === &#39;items&#39;) {
                item.sprite.putMarker(item.category, change, item.index, false, true);
            }
            if (item.sprite.isMarkerHolder &amp;&amp; item.category === &#39;markers&#39;) {
                item.sprite.putMarker(item.category, change, item.index, false, true);
            } else if (item.sprite instanceof Ext.draw.sprite.Instancing) {
                item.sprite.setAttributesFor(item.index, change);
            } else {

                item.sprite.setAttributes(change);
            }
        }
    },

<span id='Ext-chart-series-Series-method-applyHighlightItem'>    applyHighlightItem: function (newHighlightItem, oldHighlightItem) {
</span>        if (newHighlightItem === oldHighlightItem) {
            return;
        }
        if (Ext.isObject(newHighlightItem) &amp;&amp; Ext.isObject(oldHighlightItem)) {
            if (newHighlightItem.sprite === oldHighlightItem.sprite &amp;&amp;
                newHighlightItem.index === oldHighlightItem.index
                ) {
                return;
            }
        }
        return newHighlightItem;
    },

<span id='Ext-chart-series-Series-method-updateHighlightItem'>    updateHighlightItem: function (newHighlightItem, oldHighlightItem) {
</span>        this.setAttributesForItem(oldHighlightItem, {highlighted: false});
        this.setAttributesForItem(newHighlightItem, {highlighted: true});
    },

<span id='Ext-chart-series-Series-method-constructor'>    constructor: function (config) {
</span>        var me = this;
        me.getId();
        me.sprites = [];
        me.dataRange = [];
        Ext.ComponentManager.register(me);
        me.mixins.observable.constructor.apply(me, arguments);
    },

<span id='Ext-chart-series-Series-method-applyStore'>    applyStore: function (store) {
</span>        return Ext.StoreManager.lookup(store);
    },

<span id='Ext-chart-series-Series-method-getStore'>    getStore: function () {
</span>        return this._store || this.getChart() &amp;&amp; this.getChart().getStore();
    },

<span id='Ext-chart-series-Series-method-updateStore'>    updateStore: function (newStore, oldStore) {
</span>        var me = this,
            chartStore = this.getChart() &amp;&amp; this.getChart().getStore(),
            sprites = me.getSprites(),
            ln = sprites.length,
            i, sprite;
        newStore = newStore || chartStore;
        oldStore = oldStore || chartStore;

        if (oldStore) {
            oldStore.un(&#39;updaterecord&#39;, &#39;onUpdateRecord&#39;, me);
            oldStore.un(&#39;refresh&#39;, &#39;refresh&#39;, me);
        }
        if (newStore) {
            newStore.on(&#39;updaterecord&#39;, &#39;onUpdateRecord&#39;, me);
            newStore.on(&#39;refresh&#39;, &#39;refresh&#39;, me);
            for (i = 0; i &lt; ln; i++) {
                sprite = sprites[i];
                if (sprite.setStore) {
                    sprite.setStore(newStore);
                }
            }
            me.refresh();
        }
    },

<span id='Ext-chart-series-Series-method-onStoreChanged'>    onStoreChanged: function (store, oldStore) {
</span>        if (!this._store) {
            this.updateStore(store, oldStore);
        }
    },

<span id='Ext-chart-series-Series-method-coordinateStacked'>    coordinateStacked: function (direction, directionOffset, directionCount) {
</span>        var me = this,
            store = me.getStore(),
            items = store.getData().items,
            axis = me[&#39;get&#39; + direction + &#39;Axis&#39;](),
            hidden = me.getHidden(),
            range = {min: 0, max: 0},
            directions = me[&#39;fieldCategory&#39; + direction],
            fieldCategoriesItem,
            i, j, k, fields, field, data, style = {},
            dataStart = [], dataEnd, posDataStart = [], negDataStart = [],
            stacked = me.getStacked(),
            sprites = me.getSprites();

        if (sprites.length &gt; 0) {
            for (i = 0; i &lt; directions.length; i++) {
                fieldCategoriesItem = directions[i];
                fields = me.getFields([fieldCategoriesItem]);
                for (j = 0; j &lt; items.length; j++) {
                    dataStart[j] = 0;
                    posDataStart[j] = 0;
                    negDataStart[j] = 0;
                }
                for (j = 0; j &lt; fields.length; j++) {
                    style = {};
                    field = fields[j];
                    if (hidden[j]) {
                        style[&#39;dataStart&#39; + fieldCategoriesItem] = dataStart;
                        style[&#39;data&#39; + fieldCategoriesItem] = dataStart;
                        sprites[j].setAttributes(style);
                        continue;
                    }
                    data = me.coordinateData(items, field, axis);
                    if (stacked) {
                        dataEnd = [];
                        for (k = 0; k &lt; items.length; k++) {
                            if (data[k] &gt;= 0) {
                                dataStart[k] = posDataStart[k];
                                posDataStart[k] += data[k];
                                dataEnd[k] = posDataStart[k];
                            } else {
                                dataStart[k] = negDataStart[k];
                                negDataStart[k] += data[k];
                                dataEnd[k] = negDataStart[k];
                            }
                        }
                        style[&#39;dataStart&#39; + fieldCategoriesItem] = dataStart;
                        style[&#39;data&#39; + fieldCategoriesItem] = dataEnd;
                        me.getRangeOfData(dataStart, range);
                        me.getRangeOfData(dataEnd, range);
                    } else {
                        style[&#39;dataStart&#39; + fieldCategoriesItem] = dataStart;
                        style[&#39;data&#39; + fieldCategoriesItem] = data;
                        me.getRangeOfData(data, range);
                    }
                    sprites[j].setAttributes(style);
                }
            }
            me.dataRange[directionOffset] = range.min;
            me.dataRange[directionOffset + directionCount] = range.max;
            style = {};
            style[&#39;dataMin&#39; + direction] = range.min;
            style[&#39;dataMax&#39; + direction] = range.max;
            for (i = 0; i &lt; sprites.length; i++) {
                sprites[i].setAttributes(style);
            }
        }
    },

<span id='Ext-chart-series-Series-method-coordinate'>    coordinate: function (direction, directionOffset, directionCount) {
</span>        var me = this,
            store = me.getStore(),
            hidden = me.getHidden(),
            items = store.getData().items,
            axis = me[&#39;get&#39; + direction + &#39;Axis&#39;](),
            range = {min: Infinity, max: -Infinity},
            fieldCategory = me[&#39;fieldCategory&#39; + direction] || [direction],
            fields = me.getFields(fieldCategory),
            i, field, data, style = {},
            sprites = me.getSprites();
        if (sprites.length &gt; 0) {
            if (!Ext.isBoolean(hidden) || !hidden) {
                for (i = 0; i &lt; fieldCategory.length; i++) {
                    field = fields[i];
                    data = me.coordinateData(items, field, axis);
                    me.getRangeOfData(data, range);
                    style[&#39;data&#39; + fieldCategory[i]] = data;
                }
            }
            me.dataRange[directionOffset] = range.min;
            me.dataRange[directionOffset + directionCount] = range.max;
            style[&#39;dataMin&#39; + direction] = range.min;
            style[&#39;dataMax&#39; + direction] = range.max;
            if (axis) {
                axis.range = null;
                style[&#39;range&#39; + direction] = axis.getRange();
            }
            for (i = 0; i &lt; sprites.length; i++) {
                sprites[i].setAttributes(style);
            }
        }
    },

<span id='Ext-chart-series-Series-method-coordinateData'>    /**
</span>     * @private
     * This method will return an array containing data coordinated by a specific axis.
     * @param {Array} items
     * @param {String} field
     * @param {Ext.chart.axis.Axis} axis
     * @return {Array}
     */
    coordinateData: function (items, field, axis) {
        var data = [],
            length = items.length,
            layout = axis &amp;&amp; axis.getLayout(),
            coord = axis ? function (x, field, idx, items) {
                return layout.getCoordFor(x, field, idx, items);
            } : function (x) { return +x; },
            i, x;
        for (i = 0; i &lt; length; i++) {
            x = items[i].data[field];
            data[i] = !Ext.isEmpty(x) ? coord(x, field, i, items) : 0;
        }
        return data;
    },

<span id='Ext-chart-series-Series-method-getRangeOfData'>    getRangeOfData: function (data, range) {
</span>        var i, length = data.length,
            value, min = range.min, max = range.max;
        for (i = 0; i &lt; length; i++) {
            value = data[i];
            if (value &lt; min) {
                min = value;
            }
            if (value &gt; max) {
                max = value;
            }
        }
        range.min = min;
        range.max = max;
    },

<span id='Ext-chart-series-Series-method-updateLabelData'>    updateLabelData: function () {
</span>        var me = this,
            store = me.getStore(),
            items = store.getData().items,
            sprites = me.getSprites(),
            labelTpl = me.getLabel().getTemplate(),
            labelFields = Ext.Array.from(labelTpl.getField() || me.getLabelField()),
            i, j, ln, labels,
            sprite, field;

        if (!sprites.length || !labelFields.length) {
            return;
        }

        for (i = 0; i &lt; sprites.length; i++) {
            labels = [];
            sprite = sprites[i];
            field = sprite.getField();
            if (labelFields.indexOf(field) &lt; 0) {
                field = labelFields[i];
            }
            for (j = 0, ln = items.length; j &lt; ln; j++) {
                labels.push(items[j].get(field));
            }
            sprite.setAttributes({labels: labels});
        }
    },

<span id='Ext-chart-series-Series-method-updateLabelField'>    updateLabelField: function (labelField) {
</span>        var labelTpl = this.getLabel().getTemplate();
        if (!labelTpl.config.field) {
            labelTpl.setField(labelField)
        }
    },

<span id='Ext-chart-series-Series-method-processData'>    processData: function () {
</span>        if (!this.getStore()) {
            return;
        }

        var me = this,
            directions = this.directions,
            i, ln = directions.length,
            fieldCategory, axis;

        for (i = 0; i &lt; ln; i++) {
            fieldCategory = directions[i];
            if (me[&#39;get&#39; + fieldCategory + &#39;Axis&#39;]) {
                axis = me[&#39;get&#39; + fieldCategory + &#39;Axis&#39;]();
                if (axis) {
                    axis.processData(me);
                    continue;
                }
            }
            if (me[&#39;coordinate&#39; + fieldCategory]) {
                me[&#39;coordinate&#39; + fieldCategory]();
            }
        }
        me.updateLabelData();
    },

<span id='Ext-chart-series-Series-method-applyBackground'>    applyBackground: function (background) {
</span>        if (this.getChart()) {
            this.getSurface().setBackground(background);
            return this.getSurface().getBackground();
        } else {
            return background;
        }
    },

<span id='Ext-chart-series-Series-method-updateChart'>    updateChart: function (newChart, oldChart) {
</span>        var me = this;
        if (oldChart) {
            oldChart.un(&#39;axeschanged&#39;, &#39;onAxesChanged&#39;, me);
            // TODO: destroy them
            me.sprites = [];
            me.setSurface(null);
            me.setOverlaySurface(null);
            me.onChartDetached(oldChart);
        }
        if (newChart) {
            me.setSurface(newChart.getSurface(&#39;series-surface&#39;, &#39;series&#39;));
            me.setOverlaySurface(newChart.getSurface(&#39;overlay-surface&#39;, &#39;overlay&#39;));

            newChart.on(&#39;axeschanged&#39;, &#39;onAxesChanged&#39;, me);
            if (newChart.getAxes()) {
                me.onAxesChanged(newChart);
            }
            me.onChartAttached(newChart);
        }

        me.updateStore(me._store, null);
    },

<span id='Ext-chart-series-Series-method-onAxesChanged'>    onAxesChanged: function (chart) {
</span>        var me = this,
            axes = chart.getAxes(), axis,
            directionMap = {}, directionMapItem,
            fieldMap = {}, fieldMapItem,
            needHighPrecision = false,
            directions = this.directions, direction,
            i, ln, j, ln2, k, ln3;

        for (i = 0, ln = directions.length; i &lt; ln; i++) {
            direction = directions[i];
            fieldMap[direction] = me.getFields(me[&#39;fieldCategory&#39; + direction]);
        }

        for (i = 0, ln = axes.length; i &lt; ln; i++) {
            axis = axes[i];
            if (!directionMap[axis.getDirection()]) {
                directionMap[axis.getDirection()] = [axis];
            } else {
                directionMap[axis.getDirection()].push(axis);
            }
        }

        for (i = 0, ln = directions.length; i &lt; ln; i++) {
            direction = directions[i];
            if (directionMap[direction]) {
                directionMapItem = directionMap[direction];
                for (j = 0, ln2 = directionMapItem.length; j &lt; ln2; j++) {
                    axis = directionMapItem[j];
                    if (axis.getFields().length === 0) {
                        me[&#39;set&#39; + direction + &#39;Axis&#39;](axis);
                        if (axis.getNeedHighPrecision()) {
                            needHighPrecision = true;
                        }
                    } else {
                        fieldMapItem = fieldMap[direction];
                        if (fieldMapItem) {
                            for (k = 0, ln3 = fieldMapItem.length; k &lt; ln3; k++) {
                                if (axis.fieldsMap[fieldMapItem[k]]) {
                                    me[&#39;set&#39; + direction + &#39;Axis&#39;](axis);
                                    if (axis.getNeedHighPrecision()) {
                                        needHighPrecision = true;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        this.getSurface().setHighPrecision(needHighPrecision);
    },

<span id='Ext-chart-series-Series-method-onChartDetached'>    onChartDetached: function (oldChart) {
</span>        var me = this;
        me.fireEvent(&#39;chartdetached&#39;, oldChart, me);
        oldChart.un(&#39;storechanged&#39;, &#39;onStoreChanged&#39;, me);
    },

<span id='Ext-chart-series-Series-method-onChartAttached'>    onChartAttached: function (chart) {
</span>        var me = this;
        me.setBackground(me.getBackground());
        me.fireEvent(&#39;chartattached&#39;, chart, me);
        chart.on(&#39;storechanged&#39;, &#39;onStoreChanged&#39;, me);
        me.processData();
    },

<span id='Ext-chart-series-Series-method-updateOverlaySurface'>    updateOverlaySurface: function (overlaySurface) {
</span>        var me = this;
        if (overlaySurface) {
            if (me.getLabel()) {
                me.getOverlaySurface().add(me.getLabel());
            }
        }
    },

<span id='Ext-chart-series-Series-method-applyLabel'>    applyLabel: function (newLabel, oldLabel) {
</span>        if (!oldLabel) {
            oldLabel = new Ext.chart.Markers({zIndex: 10});
            oldLabel.setTemplate(new Ext.chart.label.Label(newLabel));
        } else {
            oldLabel.getTemplate().setAttributes(newLabel);
        }
        return oldLabel;
    },

<span id='Ext-chart-series-Series-method-createItemInstancingSprite'>    createItemInstancingSprite: function (sprite, itemInstancing) {
</span>        var me = this,
            template,
            markers = new Ext.chart.Markers();

        markers.setAttributes({zIndex: Number.MAX_VALUE});
        var config = Ext.apply({}, itemInstancing);
        if (me.getHighlightCfg()) {
            config.highlightCfg = me.getHighlightCfg();
            config.modifiers = [&#39;highlight&#39;];
        }
        markers.setTemplate(config);
        template = markers.getTemplate();
        template.setAttributes(me.getStyle());
        template.fx.on(&#39;animationstart&#39;, &#39;onSpriteAnimationStart&#39;, this);
        template.fx.on(&#39;animationend&#39;, &#39;onSpriteAnimationEnd&#39;, this);
        sprite.bindMarker(&#39;items&#39;, markers);

        me.getSurface().add(markers);
        return markers;
    },

<span id='Ext-chart-series-Series-method-getDefaultSpriteConfig'>    getDefaultSpriteConfig: function () {
</span>        return {
            type: this.seriesType,
            renderer: this.getRenderer()
        };
    },

<span id='Ext-chart-series-Series-method-createSprite'>    createSprite: function () {
</span>        var me = this,
            surface = me.getSurface(),
            itemInstancing = me.getItemInstancing(),
            marker, config,
            sprite = surface.add(me.getDefaultSpriteConfig());

        sprite.setAttributes(this.getStyle());

        if (itemInstancing) {
            sprite.itemsMarker = me.createItemInstancingSprite(sprite, itemInstancing);
        }

        if (sprite.bindMarker) {
            if (me.getMarker()) {
                marker = new Ext.chart.Markers();
                config = Ext.merge({}, me.getMarker());
                if (me.getHighlightCfg()) {
                    config.highlightCfg = me.getHighlightCfg();
                    config.modifiers = [&#39;highlight&#39;];
                }
                marker.setTemplate(config);
                marker.getTemplate().fx.setCustomDuration({
                    translationX: 0,
                    translationY: 0
                });
                sprite.dataMarker = marker;
                sprite.bindMarker(&#39;markers&#39;, marker);
                me.getOverlaySurface().add(marker);
            }
            if (me.getLabel().getTemplate().getField() || me.getLabelField()) {
                sprite.bindMarker(&#39;labels&#39;, me.getLabel());
            }
        }

        if (sprite.setStore) {
            sprite.setStore(me.getStore());
        }

        sprite.fx.on(&#39;animationstart&#39;, &#39;onSpriteAnimationStart&#39;, me);
        sprite.fx.on(&#39;animationend&#39;, &#39;onSpriteAnimationEnd&#39;, me);

        me.sprites.push(sprite);

        return sprite;
    },

<span id='Ext-chart-series-Series-method-getSprites'>    /**
</span>     * Performs drawing of this series.
     */
    getSprites: Ext.emptyFn,

<span id='Ext-chart-series-Series-method-onUpdateRecord'>    onUpdateRecord: function () {
</span>        // TODO: do something REALLY FAST.
        this.processData();
    },

<span id='Ext-chart-series-Series-method-refresh'>    refresh: function () {
</span>        this.processData();
    },

<span id='Ext-chart-series-Series-method-isXType'>    isXType: function (xtype) {
</span>        return xtype === &#39;series&#39;;
    },

<span id='Ext-chart-series-Series-method-getItemId'>    getItemId: function () {
</span>        return this.getId();
    },

<span id='Ext-chart-series-Series-method-applyStyle'>    applyStyle: function (style, oldStyle) {
</span>        // TODO: Incremental setter
        var cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias(&#39;sprite.&#39; + this.seriesType));
        if (cls &amp;&amp; cls.def) {
            style = cls.def.normalize(style);
        }
        return Ext.apply(oldStyle || Ext.Object.chain(this.getThemeStyle()), style);
    },

<span id='Ext-chart-series-Series-method-applyMarker'>    applyMarker: function (marker, oldMarker) {
</span>        var type = (marker &amp;&amp; marker.type) || (oldMarker &amp;&amp; oldMarker.type) || this.seriesType,
            cls;
        if (type) {
            cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias(&#39;sprite.&#39; + type));
            if (cls &amp;&amp; cls.def) {
                marker = cls.def.normalize(marker, true);
                marker.type = type;
                return Ext.merge(oldMarker || {}, marker);
            }
            return Ext.merge(oldMarker || {}, marker);
        }
    },

<span id='Ext-chart-series-Series-method-applyMarkerSubStyle'>    applyMarkerSubStyle: function (marker, oldMarker) {
</span>        var type = (marker &amp;&amp; marker.type) || (oldMarker &amp;&amp; oldMarker.type) || this.seriesType,
            cls;
        if (type) {
            cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias(&#39;sprite.&#39; + type));
            if (cls &amp;&amp; cls.def) {
                marker = cls.def.batchedNormalize(marker, true);
                return Ext.merge(oldMarker || {}, marker);
            }
            return Ext.merge(oldMarker || {}, marker);
        }
    },

<span id='Ext-chart-series-Series-method-applySubStyle'>    applySubStyle: function (subStyle, oldSubStyle) {
</span>        var cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias(&#39;sprite.&#39; + this.seriesType));
        if (cls &amp;&amp; cls.def) {
            subStyle = cls.def.batchedNormalize(subStyle, true);
            return Ext.merge(oldSubStyle || {}, subStyle);
        }
        return Ext.merge(oldSubStyle || {}, subStyle);
    },

<span id='Ext-chart-series-Series-method-updateHidden'>    updateHidden: function (hidden) {
</span>        // TODO: remove this when jacky fix the problem.
        this.getColors();
        this.getSubStyle();
        this.setSubStyle({hidden: hidden});
        this.processData();
        this.doUpdateStyles();
    },

<span id='Ext-chart-series-Series-method-setHiddenByIndex'>    /**
</span>     *
     * @param {Number} index
     * @param {Boolean} value
     */
    setHiddenByIndex: function (index, value) {
        if (Ext.isArray(this.getHidden())) {
            this.getHidden()[index] = value;
            this.updateHidden(this.getHidden());
        } else {
            this.setHidden(value);
        }
    },

<span id='Ext-chart-series-Series-method-updateStyle'>    updateStyle: function () {
</span>        this.doUpdateStyles();
    },

<span id='Ext-chart-series-Series-method-updateSubStyle'>    updateSubStyle: function () {
</span>        this.doUpdateStyles();
    },

<span id='Ext-chart-series-Series-method-doUpdateStyles'>    doUpdateStyles: function () {
</span>        var sprites = this.sprites,
            itemInstancing = this.getItemInstancing(),
            i = 0, ln = sprites &amp;&amp; sprites.length,
            markerCfg = this.getMarker(),
            style;
        for (; i &lt; ln; i++) {
            style = this.getStyleByIndex(i);
            if (itemInstancing) {
                sprites[i].itemsMarker.getTemplate().setAttributes(style);
            }
            sprites[i].setAttributes(style);
            if (markerCfg &amp;&amp; sprites[i].dataMarker) {
                sprites[i].dataMarker.getTemplate().setAttributes(this.getMarkerStyleByIndex(i));
            }
        }
    },

<span id='Ext-chart-series-Series-method-getMarkerStyleByIndex'>    getMarkerStyleByIndex: function (i) {
</span>        return this.getOverriddenStyleByIndex(i, this.getOverriddenStyleByIndex(i, this.getMarkerSubStyle(), this.getMarker()), this.getStyleByIndex(i));
    },

<span id='Ext-chart-series-Series-method-getStyleByIndex'>    getStyleByIndex: function (i) {
</span>        return this.getOverriddenStyleByIndex(i, this.getSubStyle(), this.getStyle());
    },

<span id='Ext-chart-series-Series-method-getOverriddenStyleByIndex'>    getOverriddenStyleByIndex: function (i, subStyle, baseStyle) {
</span>        var subStyleItem,
            result = Ext.Object.chain(baseStyle || {});
        for (var name in subStyle) {
            subStyleItem = subStyle[name];
            if (Ext.isArray(subStyleItem)) {
                result[name] = subStyleItem[i % subStyle[name].length];
            } else {
                result[name] = subStyleItem;
            }
        }
        return result;
    },

<span id='Ext-chart-series-Series-method-getItemForPoint'>    /**
</span>     * For a given x/y point relative to the main region, find a corresponding item from this
     * series, if any.
     * @param {Number} x
     * @param {Number} y
     * @param {Object} [target] optional target to receive the result
     * @return {Object} An object describing the item, or null if there is no matching item. The exact contents of
     * this object will vary by series type, but should always contain at least the following:
     *
     * @return {Ext.data.Model} return.record the record of the item.
     * @return {Array} return.point the x/y coordinates relative to the chart box of a single point
     * for this data item, which can be used as e.g. a tooltip anchor point.
     * @return {Ext.draw.sprite.Sprite} return.sprite the item&#39;s rendering Sprite.
     * @return {Number} return.subSprite the index if sprite is an instancing sprite.
     */
    getItemForPoint: Ext.emptyFn,

<span id='Ext-chart-series-Series-method-onSpriteAnimationStart'>    onSpriteAnimationStart: function (sprite) {
</span>        this.fireEvent(&#39;animationstart&#39;, sprite);
    },

<span id='Ext-chart-series-Series-method-onSpriteAnimationEnd'>    onSpriteAnimationEnd: function (sprite) {
</span>        this.fireEvent(&#39;animationend&#39;, sprite);
    },

<span id='Ext-chart-series-Series-method-provideLegendInfo'>    /**
</span>     * Provide legend information to target array.
     *
     * @param {Array} target
     *
     * The information consists:
     * @param {String} target.name
     * @param {String} target.markColor
     * @param {Boolean} target.disabled
     * @param {String} target.series
     * @param {Number} target.index
     */
    provideLegendInfo: function (target) {
        target.push({
            name: this.getTitle() || this.getId(),
            mark: &#39;black&#39;,
            disabled: false,
            series: this.getId(),
            index: 0
        });
    },

<span id='Ext-chart-series-Series-method-destroy'>    destroy: function () {
</span>        this.clearListeners();
        Ext.ComponentManager.unregister(this);
        var store = this.getStore();
        if (store &amp;&amp; store.getAutoDestroy()) {
            Ext.destroy(store);
        }
        this.setStore(null);
        this.callSuper();
    }
});
</pre>
</body>
</html>
